// Code generated by go-enum DO NOT EDIT.
// Version: 0.6.1
// Revision: a6f63bddde05aca4221df9c8e9e6d7d9674b1cb4
// Build Date: 2025-03-18T23:42:14Z
// Built By: goreleaser

package sbcgostructgen

import (
	"fmt"
	"strings"
)

const (
	// FieldTypeVoid is a fieldType of type void*.
	FieldTypeVoid fieldType = "void*"
	// FieldTypeChar is a fieldType of type char*.
	FieldTypeChar fieldType = "char*"
	// FieldTypeInt8T is a fieldType of type int8_t.
	FieldTypeInt8T fieldType = "int8_t"
	// FieldTypeInt16T is a fieldType of type int16_t.
	FieldTypeInt16T fieldType = "int16_t"
	// FieldTypeInt32T is a fieldType of type int32_t.
	FieldTypeInt32T fieldType = "int32_t"
	// FieldTypeInt64T is a fieldType of type int64_t.
	FieldTypeInt64T fieldType = "int64_t"
	// FieldTypeUint8T is a fieldType of type uint8_t.
	FieldTypeUint8T fieldType = "uint8_t"
	// FieldTypeUint16T is a fieldType of type uint16_t.
	FieldTypeUint16T fieldType = "uint16_t"
	// FieldTypeUint32T is a fieldType of type uint32_t.
	FieldTypeUint32T fieldType = "uint32_t"
	// FieldTypeUint64T is a fieldType of type uint64_t.
	FieldTypeUint64T fieldType = "uint64_t"
	// FieldTypeFloat is a fieldType of type float.
	FieldTypeFloat fieldType = "float"
	// FieldTypeDouble is a fieldType of type double.
	FieldTypeDouble fieldType = "double"
	// FieldTypeBool is a fieldType of type bool.
	FieldTypeBool fieldType = "bool"
)

var ErrInvalidfieldType = fmt.Errorf("not a valid fieldType, try [%s]", strings.Join(_fieldTypeNames, ", "))

var _fieldTypeNames = []string{
	string(FieldTypeVoid),
	string(FieldTypeChar),
	string(FieldTypeInt8T),
	string(FieldTypeInt16T),
	string(FieldTypeInt32T),
	string(FieldTypeInt64T),
	string(FieldTypeUint8T),
	string(FieldTypeUint16T),
	string(FieldTypeUint32T),
	string(FieldTypeUint64T),
	string(FieldTypeFloat),
	string(FieldTypeDouble),
	string(FieldTypeBool),
}

// fieldTypeNames returns a list of possible string values of fieldType.
func fieldTypeNames() []string {
	tmp := make([]string, len(_fieldTypeNames))
	copy(tmp, _fieldTypeNames)
	return tmp
}

// fieldTypeValues returns a list of the values for fieldType
func fieldTypeValues() []fieldType {
	return []fieldType{
		FieldTypeVoid,
		FieldTypeChar,
		FieldTypeInt8T,
		FieldTypeInt16T,
		FieldTypeInt32T,
		FieldTypeInt64T,
		FieldTypeUint8T,
		FieldTypeUint16T,
		FieldTypeUint32T,
		FieldTypeUint64T,
		FieldTypeFloat,
		FieldTypeDouble,
		FieldTypeBool,
	}
}

// String implements the Stringer interface.
func (x fieldType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x fieldType) IsValid() bool {
	_, err := ParsefieldType(string(x))
	return err == nil
}

var _fieldTypeValue = map[string]fieldType{
	"void*":    FieldTypeVoid,
	"char*":    FieldTypeChar,
	"int8_t":   FieldTypeInt8T,
	"int16_t":  FieldTypeInt16T,
	"int32_t":  FieldTypeInt32T,
	"int64_t":  FieldTypeInt64T,
	"uint8_t":  FieldTypeUint8T,
	"uint16_t": FieldTypeUint16T,
	"uint32_t": FieldTypeUint32T,
	"uint64_t": FieldTypeUint64T,
	"float":    FieldTypeFloat,
	"double":   FieldTypeDouble,
	"bool":     FieldTypeBool,
}

// ParsefieldType attempts to convert a string to a fieldType.
func ParsefieldType(name string) (fieldType, error) {
	if x, ok := _fieldTypeValue[name]; ok {
		return x, nil
	}
	return fieldType(""), fmt.Errorf("%s is %w", name, ErrInvalidfieldType)
}

// MarshalText implements the text marshaller method.
func (x fieldType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *fieldType) UnmarshalText(text []byte) error {
	tmp, err := ParsefieldType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

const (
	// TypeModNone is a typeMod of type None.
	TypeModNone typeMod = iota
	// TypeModPntr is a typeMod of type Pntr.
	TypeModPntr
	// TypeModArray is a typeMod of type Array.
	TypeModArray
)

var ErrInvalidtypeMod = fmt.Errorf("not a valid typeMod, try [%s]", strings.Join(_typeModNames, ", "))

const _typeModName = "NonePntrArray"

var _typeModNames = []string{
	_typeModName[0:4],
	_typeModName[4:8],
	_typeModName[8:13],
}

// typeModNames returns a list of possible string values of typeMod.
func typeModNames() []string {
	tmp := make([]string, len(_typeModNames))
	copy(tmp, _typeModNames)
	return tmp
}

// typeModValues returns a list of the values for typeMod
func typeModValues() []typeMod {
	return []typeMod{
		TypeModNone,
		TypeModPntr,
		TypeModArray,
	}
}

var _typeModMap = map[typeMod]string{
	TypeModNone:  _typeModName[0:4],
	TypeModPntr:  _typeModName[4:8],
	TypeModArray: _typeModName[8:13],
}

// String implements the Stringer interface.
func (x typeMod) String() string {
	if str, ok := _typeModMap[x]; ok {
		return str
	}
	return fmt.Sprintf("typeMod(%d)", x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x typeMod) IsValid() bool {
	_, ok := _typeModMap[x]
	return ok
}

var _typeModValue = map[string]typeMod{
	_typeModName[0:4]:  TypeModNone,
	_typeModName[4:8]:  TypeModPntr,
	_typeModName[8:13]: TypeModArray,
}

// ParsetypeMod attempts to convert a string to a typeMod.
func ParsetypeMod(name string) (typeMod, error) {
	if x, ok := _typeModValue[name]; ok {
		return x, nil
	}
	return typeMod(0), fmt.Errorf("%s is %w", name, ErrInvalidtypeMod)
}

// MarshalText implements the text marshaller method.
func (x typeMod) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *typeMod) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParsetypeMod(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}
